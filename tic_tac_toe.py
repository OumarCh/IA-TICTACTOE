# -*- coding: utf-8 -*-
"""tic-tac-toe.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JW25kFshuhmdRifn3ZKYe7g4FtHtS-m3
"""

from pprint import pprint
import pandas as pd
import sys, os
import random
import copy

HUMAN = 1
COMP = -1


def init():
    grid = int(input("Choisir votre grille : 3(3x3), 5(5x5) ou 7(7x7): "))
    game = [[0 for j in range(grid)] for i in range(grid)]
    return game, grid


game, grid = init()

df = pd.DataFrame(game)


def is_empty_box(game, x, y):
    if game[x][y] == 1 or game[x][y] == -1:
        return False
    return True


def format_game(df):
    df = df.replace([1], 'X')
    df = df.replace([-1], 'O')
    df = df.replace([0], '.')

    return df


def check_diago_top(state, posx, posy):
    """
    """
    x = posx
    y = posy

    try:
        if x - (comboforWin - 1) >= 0 and y + (comboforWin - 1) and comboforWin == 3:
            diagoT = [state[x][y], state[x - 1][y + 1], state[x - 2][y + 2]]
        elif x - (comboforWin - 1) >= 0 and y + (comboforWin - 1) < grid and comboforWin == 4:
            diagoT = [state[x][y], state[x - 1][y + 1], state[x - 2][y + 2], state[x - 3][y + 3]]
        return diagoT
    except:
        pass

    return


def check_the_column(state, posx, posy):
    """
    """
    column = []
    if posx + (comboforWin - 1) < grid:
        for i in range(comboforWin):
            column.append(state[posx][posy])
            posx += 1
        return column
    return


def check_diago_bottom(state, posx, posy):
    """
    """
    x = posx
    y = posy
    try:
        if comboforWin == 3:
            diagoB = [state[x][y], state[x + 1][y + 1], state[x + 2][y + 2]]
        elif comboforWin == 4:
            diagoB = [state[x][y], state[x + 1][y + 1], state[x + 2][y + 2], state[x + 3][y + 3]]
        return diagoB
    except:
        pass

    return


def check_the_line(state, posx, posy):
    """
    """
    line = []
    if posy + (comboforWin - 1) < grid:
        for i in range(comboforWin):
            line.append(state[posx][posy + i])
        return line
    return


def genere_params_for_win(grilles):
    if grilles == 3:
        comboforWin = 3
    else:
        comboforWin = 4
    return comboforWin


comboforWin = genere_params_for_win(grid)


def create_win_possibility(state):
    wins_state = []
    for x in range(len(state)):
        for y in range(len(state)):
            line = check_the_line(state, x, y)
            if line:
                wins_state.append(line)

            column = check_the_column(state, x, y)
            if column:
                wins_state.append(column)
            diago_bottom = check_diago_bottom(state, x, y)
            if diago_bottom:
                wins_state.append(diago_bottom)

            diago_top = check_diago_top(state, x, y)
            if diago_top:
                wins_state.append(diago_top)
    return wins_state


def wins(state, player):
    win_state = create_win_possibility(state)
    if genere_params_for_win(grid) == 3 and [player, player, player] in win_state:
        return True
    elif genere_params_for_win(grid) == 4 and [player, player, player, player] in win_state:
        return True
    else:
        return False


def play_naive(game):
    is_end = False
    player = 1
    count = 0
    while is_end == False:
        if count == 0:
            print(pd.DataFrame(game))

        if player == 1:
            print("Placer votre pion sur une coordonnée (x, y)")
            x = int(input("Choisir l'abscisse: "))
            y = int(input("Choisir l'ordonnée: "))

        if player == -1:
            x = random.randint(0, grid - 1)
            y = random.randint(0, grid - 1)

        if is_empty_box(game, x, y) == False:
            while is_empty_box(game, x, y) == False:
                if player == 1:
                    print("Case prise, veuillez réessayer")
                    x = int(input("Choisir l'abscisse: "))
                    y = int(input("Choisir l'ordonnée: "))
                if player == -1:
                    x = random.randint(0, grid - 1)
                    y = random.randint(0, grid - 1)

        game[x][y] = player
        show_ground = copy.deepcopy(game)
        count = count + 1

        is_win = wins(game, player)
        if count > 0:
            # show_ground[x][y] = 'X' if player == 1 else 'O'
            df = pd.DataFrame(show_ground)
            df = format_game(df)
            print(df)

        if is_win == True:
            name = ""
            is_end = True
            if player == 1:
                name = "Humain"
            else:
                name = "Machine"
            print("{} a gagné".format(name))
        else:
            if len(empty_cells(game)) == 0:
                print("Match nul")
                is_end = True

        player = -player


# play_naive(game)

def evaluate(state):
    """
    Perform heuristic evaluation from board.
    Heuristic - allow the computer to discover the solution
    of some problems by itself.
    """
    if wins(state, COMP):
        score = -1
    elif wins(state, HUMAN):
        score = 1
    else:
        score = 0

    return score


def empty_cells(state):
    """
    Identifier à chaque étape du jeu les cellules qui reste à cocher
    """
    cells = []  # it contains all empty cells

    # Use enumerate for easy indexing
    for i, row in enumerate(state):
        for j, col in enumerate(row):
            if state[i][j] == 0:
                cells.append([i, j])

    return cells


def game_over(state):
    """Check game over condition"""
    return wins(state, HUMAN) or wins(state, COMP)


evaluate(game)


def minimax(state, depth, player):
    """
    Ns implémentons `MiniMax` (Algo IA) ce qui permettra de
    déterminer d'une façon optimale les actions de `COMP`.
    Le jeu `tictactoe` peut en effet être présenté sous la forme d'un arbre. 
    L'Algo MiniMax traverse l'arbre d'une façon récursive pour trouver les meilleures combinaisons possibles.
    :return list of [best_row, best_col, best_score]
    """

    from math import inf
    if player == COMP:
        best = [-1, -1, inf]  # inf/-inf are the initial score for the players
    else:
        best = [-1, -1, -inf]

    if depth == 0 or game_over(state):
        score = evaluate(state)
        return [-1, -1, score]
# Limit depth for board 5x5 & 7x7
    if depth > 10:
        depth = 3

    for cell in empty_cells(state):
        # Fill the empty cells with the player symbols
        x, y = cell[0], cell[1]
        state[x][y] = player
        #        print('\ncell : ', cell)
        #        print('\nsymbole : ', player)
        score = minimax(state, depth - 1, -player)
        #        print('\nscore : ', score)
        state[x][y] = 0
        score[0], score[1] = x, y

        if player == COMP:
            if score[2] < best[2]:
                best = score
        #               print('\nbest : ', best)
        else:
            if score[2] > best[2]:
                best = score
    #               print('\nbest : ', best)

    return best


def ai_turn(state):
    depth = len(empty_cells(state))  # The remaining of empty cells
    row, col, score = minimax(state, depth, COMP)  # the optimal move for computer
    # state[row][col] = COMP

    return row, col
    # print("A.I Turn")
    # print(render(state))


def main(game):
    is_end = False
    player = 1
    count = 0
    while is_end == False:
        if count == 0:
            print(format_game(pd.DataFrame(game)))

        if player == 1:
            print("Placer votre pion sur une coordonnée (x, y)")
            x = int(input("Choisir ligne: "))
            y = int(input("Choisir colonne: "))

        if player == -1:
            x, y = ai_turn(game)
            print('row col', x, y)

        if is_empty_box(game, x, y) == False:
            while is_empty_box(game, x, y) == False:
                if player == 1:
                    print("Case prise, veuillez réessayer")
                    x = int(input("Choisir ligne: "))
                    y = int(input("Choisir colonne: "))
                if player == -1:
                    x, y = ai_turn(game)
                    print('row col', x, y)

        game[x][y] = player
        show_ground = copy.deepcopy(game)
        count = count + 1

        is_win = wins(game, player)
        if count > 0:
            df = pd.DataFrame(show_ground)
            df = format_game(df)
            print(df)

        if is_win == True:
            is_end = True
            name = ""
            if player == 1:
                name = "Humain"
            else:
                name = "Machine"
            print("{} a gagné".format(name))
        else:
            if len(empty_cells(game)) == 0:
                print("Match nul")
                is_end = True

        player = -player


if __name__ == '__main__':
    main(game)

minimax(game, 4, 1)
